# Solo Market 说明文档

本文档详细说明了 `solomarket.py` 脚本的核心执行逻辑和设计原理。

**Author**: @0xwenjian

---

## 核心配置参数

- **`min_protection_amount`**: 最小前方保护金额（例如 $500）
  - 用途：确保挂单前方有足够的订单保护，降低被成交风险
  
- **`order_amount`**: 每次挂单金额（例如 $50）
  - 用途：控制单次挂单的资金量

---

## 一、价格计算逻辑

### 核心原理

脚本通过 `calculate_safe_price` 方法遍历**整个**订单簿，寻找第一个满足保护要求的档位。关键特点：

1. **极致保守的累计保护**：采用"队列首位"风险假设。即假设我们在同价位单子中排在最前面，因此**同价位单子不计入保护**。只有比我们价格更好的单子才有保护作用。
2. **全局扫描**：始终遍历整个订单簿，找到**第一个**满足保护金额的档位。
3. **绝不当出头鸟**：由于同价位保护为 0，Bot 永远不会挂在买 1 位置。


**示例**：
```
订单簿：
买1: 0.3520 @ $800
买2: 0.3500 @ $400

配置：min_protection_amount = $500

执行结果：
- 考察买1 (0.3520)：自身金额 $800 >= $500 ✓
- 挂单价格 = 0.3520 - 0.001 = 0.3510
- 挂单档位 = 买2 (事实上的新买2，排在原买2之前)
```

**关键结论**：如果买1这把"伞"足够大，我们就紧贴着它站（买1价格 - 0.001）；如果买1太薄，我们才会继续向后累加。但无论如何，机器人**永远不会**直接挂在买1价格上。

---

## 二、下单与调整逻辑

### 核心流程（每 3 秒执行一次）

```
获取订单簿 → 计算最优安全位置 → 与当前位置比较
　├── 相同 → 保持不动
　├── 新位置更靠前 → 撤单，向前移动（前进）
　└── 新位置更靠后 → 撤单，向后移动（后退）
```

### 初始下单

1. **获取订单簿**：抓取实时盘口数据。
2. **全局搜索安全点**：遍历整个订单簿，找到第一个累计保护 >= `min_protection_amount` 的档位 i。
3. **挂单**：以 `买i价格 - 0.001` 挂单。

### 持续调整

每 3 秒检查一次，Bot 会重新计算最优安全位置：

- **前进**：如果前方订单簿变厚了（比如新的大单出现），计算出的最优位置更靠前，Bot 自动撤单向前挪。
- **后退**：如果前方变薄了（比如大单被吃掉），保护不足，Bot 自动撤单向后退。
- **不动**：如果最优位置没变，保持原位。

**示例：前进**
```
当前位置：买10 @ 0.3420

盘口变化：买2 出现一笔 $5000 的大单
重新计算：买2 累计保护已满足 → 最优位置 = 买3
操作：撤掉买10的单，重新挂到 0.3490（买2价 - 0.001）
```

**示例：后退**
```
当前位置：买3 @ 0.3490

盘口变化：买1、买2 的大单被吃掉
重新计算：前方保护不足 → 最优位置 = 买8
操作：撤掉买3的单，重新挂到 0.3430（买7价 - 0.001）
```

---

## 三、保护金额计算详解

### 什么是保护金额？

保护金额是指您的挂单**前方**所有买单的总金额。这些订单为您的订单提供"保护"，因为买家必须先吃掉这些订单才能成交到您的订单。

### 计算方法：First-In-Queue 假设

在计算保护时，我们假设自己处于同价位队列的最前端：

1. **确定档位**：统计有多少个价格高于我们的订单。
2. **累计金额**：**只计算**价格严格高于我们的档位金额。
3. **同价位保护**：计为 **$0**。

### 示例

```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400

我们的挂单：0.3510

计算结果：
- 真实档位：买2
- 前方保护：$800 (只有买1)
- 同价位保护：$0 (虽然买2有$400，但不计入)
```

### 为什么要这么算？

这是为了应对极端的"虚假挂单"或"快速撤单"。如果同价位的单子瞬间撤销，只有价格更高的档位才能真正起到缓冲作用。

---

## 四、完整流程示例

### 场景：从初始化到调整

**配置**：
- `min_protection_amount = $500`
- `order_amount = $30`

#### 步骤 1：首次下单

```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400

执行：
1. 考察买1: 累计保护 $800 >= $500 ✓
2. 挂单成功：0.3510 @ $30 (买1价 - 0.001)
```

#### 步骤 2：市场变化，保护不足（后退）

```
新状态：买1被吃掉，我们的订单变成买1
检测：前方保护 $0 < $500 -> 需要后退
重新计算：全局扫描，找到新的安全位置
操作：撤单，向后移动到安全档位
```

#### 步骤 3：市场恢复，前方出现安全位置（前进）

```
当前位置：买9 (因为之前市场剧波动躲得很深)
市场恢复：买1-3 出现了厚实的挂单
检测：重新计算发现最优安全位置在买4
操作：自动撤单并搬家到买4
```

---

## 五、设计原则

### 1. 安全优先

脚本的核心目标是**提供流动性而非成交**。所有逻辑都围绕这一原则：

- **买1特殊处理**：永不直接挂买1价，避免被快速成交
- **保护金额机制**：确保前方有足够的订单作为缓冲
- **全局扫描**：始终找到最优安全位置

### 2. 动态调整

- **双向移动**：既会向后退避，也会自动向前靠拢
- **单一判断标准**：只看保护金额是否满足，逻辑简单可靠
- **3 秒周期**：平衡了响应速度和 API 负载

### 3. 透明可控

- **详细日志**：记录每次下单、调整的原因和结果
- **清晰逻辑**：统一的判断标准，无复杂的多触发器
- **可配置参数**：用户可以根据需求调整保护金额和挂单金额

### 4. 成交检测

脚本会定期检查订单状态，如果检测到订单被成交（status = 3 或 'filled'），会：
- 记录警告日志：`⚠️ [非预期成交]`
- 显示成交详情：市场、价格、金额、持续时间
- 从监控列表中移除该订单

----

#### 多账号启动
你可以为不同的账号准备不同的环境和配置文件，例如：
- 账号1: `python3 solomarket.py --env-file account_1.env --config-file account_1.config.yaml`
- 账号2: `python3 solomarket.py --env-file account_2.env --config-file account_2.config.yaml`
指令中的文件名可以根据你的实际需求自定义。