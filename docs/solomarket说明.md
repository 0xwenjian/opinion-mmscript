# Solo Market 说明文档

本文档详细说明了 `solomarket.py` 脚本的核心执行逻辑和设计原理。

**Author**: @0xwenjian

---

## 核心配置参数

- **`min_protection_amount`**: 最小前方保护金额（例如 $160）
  - 用途：确保挂单前方有足够的订单保护，降低被成交风险
  
- **`check_bid_position`**: 首选档位上限（例如 6）
  - 用途：Bot 倾向于挂在此档位以内（更靠前）。
  - 注意：如果此范围内没有满足保护要求的位置，Bot 会自动向更深档位搜索，确保能下单成功。
  
- **`order_amount`**: 每次挂单金额（例如 $60）
  - 用途：控制单次挂单的资金量

---

## 一、价格计算逻辑

### 核心原理

脚本通过 `calculate_safe_price` 方法遍历订单簿，寻找第一个满足保护要求的档位。关键特点：

1. **极致保守的累计保护**：采用"队列首位"风险假设。即假设我们在同价位单子中排在最前面，因此**同价位单子不计入保护**。只有比我们价格更好的单子才有保护作用。
2. **档位范围自适应**：优先在 `check_bid_position` 范围内寻找。若范围内不安全，则自动进行全局搜索，向后挂单。
3. **绝不当出头鸟**：由于同价位保护为 0，Bot 永远不会挂在买 1 位置。


**示例**：
```
订单簿：
买1: 0.3520 @ $800
买2: 0.3500 @ $400

配置：min_protection_amount = $500

执行结果：
- 考察买1 (0.3520)：自身金额 $800 >= $500 ✓
- 挂单价格 = 0.3520 - 0.001 = 0.3510
- 挂单档位 = 买2 (事实上的新买2，排在原买2之前)
```

**关键结论**：如果买1这把“伞”足够大，我们就紧贴着它站（买1价格 - 0.001）；如果买1太薄，我们才会继续向后累加。但无论如何，机器人**永远不会**直接挂在买1价格上。

---

## 二、初始下单逻辑

### 执行流程

1. **获取订单簿**：抓取实时盘口数据。
2. **全局搜索安全点**：直接在整个订单簿中寻找第一个满足保护金额的档位 $i$，并以 `买档位i价格 - 0.001` 进行挂单。
3. **策略性深挂**：即使计算出的位置超出了 `check_bid_position`（首选区域），Bot 也会**下单**，先确保留在场内获得保护。
4. **后续智能回归**：一旦挂单成功，【触发器 B】会持续寻找首选区域内的机会。只要该区域变安全，Bot 会自动撤单并向前“回归”。

### 档位策略的作用 (check_bid_position)

在该逻辑下，`check_bid_position` 定义了您的**理想活跃区域**：
- **初始不设限**：下单时只求安全，位置不限。
- **自动回归能力**：Bot 一旦发现“理想区域”内重新出现了安全的位置，会自动通过【触发器 B】搬家回来。

**示例**：
```
配置：check_bid_position = 6, min_protection_amount = $3000

订单簿：
买1-买6: 每档约为 $400，累计保护约为 $2400 (不满足)
买7: $800

执行结果：
- 范围内 (1-6) 找不到安全点。
- 启动全局搜索，发现买7累计保护达 $3200。
- 最终挂单于买7价格，确保初始安全性。
```

---

## 三、订单调整逻辑

脚本会持续监控已下订单的状态，根据市场变化自动调整。有两个触发器：

### 触发器 A：保护不足
**触发条件**：当前订单前方的保护金额 < `min_protection_amount`。
**优先级**：最高（保命触发）。
**执行**：机器人会先看范围内是否有位置，如果还没有，就全局扫描找最近的安全点躲避。

### 触发器 B：档位超标 (回归逻辑)
**触发条件**：当前订单处于 `check_bid_position` 之外（例如在买9），**且** `1 ~ check_bid_position` 范围内**重新出现了**安全位置。
**优先级**：次高（效率触发）。
**执行**：撤掉买9的单子，重新补位到范围内的安全点（如买6）。
**关键改进**：如果范围内依然无法满足保护，机器人会安心留在买9观察，而不会频繁撤单或刷屏。

### 两个触发器的对比

| 特性 | 保护不足 (躲避) | 档位超标 (回归) |
|------|---------|---------|
| **核心目的** | 躲避风险 | 提高挂单效率 |
| **触发点** | 保护金额达不到要求 | 范围内出现了新的安全点 |
| **结果** | 撤单，向更深处移动 | 撤单，向前方移动 |

---

## 四、保护金额计算详解

### 什么是保护金额？

保护金额是指您的挂单**前方**所有买单的总金额。这些订单为您的订单提供"保护"，因为买家必须先吃掉这些订单才能成交到您的订单。

### 计算方法：First-In-Queue 假设

在计算保护时，我们假设自己处于同价位队列的最前端：

1. **确定档位**：统计有多少个价格高于我们的订单。
2. **累计金额**：**只计算**价格严格高于我们的档位金额。
3. **同价位保护**：计为 **$0**。

### 示例

```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400

我们的挂单：0.3510

计算结果：
- 真实档位：买2
- 前方保护：$800 (只有买1)
- 同价位保护：$0 (虽然买2有$400，但不计入)
```

### 为什么要这么算？

这是为了应对极端的“虚假挂单”或“快速撤单”。如果同价位的单子瞬间撤销，只有价格更高的档位才能真正起到缓冲作用。

---

## 五、完整流程示例

### 场景：从初始化到调整

**配置**：
- `check_bid_position = 5`
- `min_protection_amount = $500`
- `order_amount = $30`

#### 步骤 1：首次下单

```
配置：check_bid_position = 5, min_protection = $500
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400

执行：
1. 考察买1: 保护 $0 (不满足)
2. 考察买2: 保护 $800 (满足)
3. 挂单成功：0.3510 @ $30 (买2)
```

#### 步骤 2：市场变化，触发保护不足

```
新状态：买1被吃掉，我们的订单变成买1
检测：前方保护 $0 < $500 -> 触发“保护不足”
重新挂单：向后寻找最近的安全点（如买2或买3）
```

#### 步骤 3：市场恢复，触发回归

```
当前位置：买9 (因为之前市场剧波动躲得很深)
市场恢复：买1-5 出现了厚实的挂单，满足 $500 保护
检测：当前 Rank 9 > 限制 5，且范围内有安全点
执行：触发“回归逻辑”，自动撤单并搬家回买3
```

---

## 六、设计原则

### 1. 安全优先

脚本的核心目标是**提供流动性而非成交**。所有逻辑都围绕这一原则：

- **买1特殊处理**：永不直接挂买1价，避免被快速成交
- **保护金额机制**：确保前方有足够的订单作为缓冲
- **双重触发器**：保护不足时全局扫描，确保订单始终安全

### 2. 灵活应对市场变化

- **初始下单**：首选 `check_bid_position` 区域，不理想时自动深挂。
- **保护不足**：保命优先，全局避险。
- **档位超标**：智能回归。只有当安全的前提下才往回赶。

### 3. 透明可控

- **详细日志**：记录每次下单、调整的原因和结果
- **清晰触发条件**：明确什么情况下会调整订单
- **可配置参数**：用户可以根据需求调整保护金额和档位限制

### 4. 成交检测

脚本会定期检查订单状态，如果检测到订单被成交（status = 3 或 'filled'），会：
- 记录警告日志：`⚠️ [非预期成交]`
- 显示成交详情：市场、价格、金额、持续时间
- 从监控列表中移除该订单

----

#### 多账号启动
你可以为不同的账号准备不同的环境和配置文件，例如：
- 账号1: `python3 solomarket.py --env-file account_1.env --config-file account_1.config.yaml`
- 账号2: `python3 solomarket.py --env-file account_2.env --config-file account_2.config.yaml`
指令中的文件名可以根据你的实际需求自定义。