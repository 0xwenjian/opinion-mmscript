# Solo Market 说明文档

本文档详细说明了 `solomarket.py` 脚本的核心执行逻辑和设计原理。

**Author**: @0xwenjian

---

## 核心配置参数

- **`min_protection_amount`**: 最小前方保护金额（例如 $160）
  - 用途：确保挂单前方有足够的订单保护，降低被成交风险
  
- **`check_bid_position`**: 首次下单的档位限制（例如 5）
  - 用途：限制首次下单最多只能挂在买5档位
  - 注意：这个限制**仅适用于首次下单**，订单调整时逻辑不同
  
- **`order_amount`**: 每次挂单金额（例如 $60）
  - 用途：控制单次挂单的资金量

---

## 一、价格计算逻辑

### 核心原理

脚本通过 `calculate_safe_price` 方法遍历订单簿，寻找第一个满足保护要求的档位。关键特点：

1. **累计计算保护金额**：从买1开始累加，直到累计金额达到 `min_protection_amount`
2. **档位限制可选**：可以指定搜索范围（如买1-5），也可以全局搜索
3. **买1特殊处理**：如果买1满足保护要求，挂单价格会设为 `买1价 - 0.001`

### 价格策略详解

#### 策略 1：买1满足保护

**条件**：买1档位的金额 >= 最小保护金额

**执行逻辑**：
- 挂单价格 = 买1价格 - 0.001 USD
- 实际档位：买2（因为降低0.001后通常等于买2价格）
- 前方保护：整个买1档位的金额

**示例**：
```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400
买3: 0.3500 @ $300

配置：min_protection_amount = $500

执行结果：
- 买1金额 $800 >= $500 ✓
- 挂单价格 = 0.3520 - 0.001 = 0.3510
- 挂单档位 = 买2
- 前方保护 = $800（整个买1都在前面）
```

#### 策略 2：买2及以下满足保护

**条件**：买1不满足，但买1+买2（或更多档位）累计满足保护要求

**执行逻辑**：
- 挂单价格 = 满足条件的那个档位的价格
- 实际档位：该档位
- 前方保护：该档位之前所有档位的累计金额

**示例**：
```
订单簿：
买1: 0.3520 @ $300
买2: 0.3510 @ $400
买3: 0.3500 @ $300

配置：min_protection_amount = $500

执行结果：
- 买1金额 $300 < $500 ✗
- 买1+买2累计 $700 >= $500 ✓
- 挂单价格 = 0.3510（买2价格）
- 挂单档位 = 买2
- 前方保护 = $300（只有买1在前面）
```

### 为什么买1要特殊处理？

**目的**：避免直接挂在最优价（买1价），降低被快速成交的风险。

**原理**：
- 如果直接挂买1价，我们的订单会排在买1队列的最后
- 一旦有大单买入，很容易被成交
- 通过降低0.001 USD，我们的订单会排在买2档位
- 这样前方有整个买1档位作为保护

---

## 二、初始下单逻辑

### 执行流程

1. **获取订单簿**：从 Opinion API 获取市场的实时订单簿数据
2. **限制搜索范围**：调用 `calculate_safe_price(order_book, max_rank=check_bid_position)`
3. **检查结果**：
   - 如果找到合适价格 → 下单
   - 如果找不到 → 记录警告，跳过该市场
4. **下单执行**：使用计算出的价格和金额下单

### 档位限制的作用

`check_bid_position` 限制了首次下单时的搜索范围，例如设置为 5：

- **搜索范围**：只在买1到买5之间寻找安全位置
- **目的**：避免首次下单就挂得太深，失去竞争力
- **结果**：如果买1-5都不满足保护要求，则不下单

**示例**：
```
配置：check_bid_position = 5, min_protection_amount = $500

订单簿：
买1: 0.3520 @ $100
买2: 0.3510 @ $100
买3: 0.3500 @ $100
买4: 0.3490 @ $100
买5: 0.3480 @ $100
买6: 0.3470 @ $500

执行结果：
- 买1-5累计 = $500，刚好满足
- 挂单价格 = 0.3480（买5价格）
- 挂单档位 = 买5
- 前方保护 = $400

注意：虽然买6有 $500，但超出搜索范围，不会考虑
```

---

## 三、订单调整逻辑

脚本会持续监控已下订单的状态，根据市场变化自动调整。有两个触发器：

### 触发器 A：保护不足（全局扫描）

**触发条件**：当前订单前方的保护金额 < `min_protection_amount`

**调整策略**：
- **不受档位限制**：全局扫描整个订单簿
- **目的**：保命优先，即使挂得很深也要确保安全
- **执行**：撤销当前订单，在新位置重新下单

**示例**：
```
当前状态：
- 挂单：0.3500 @ $30（买3价位）
- 前方保护：$700（买1 $400 + 买2 $300）

市场变化：
买1和买2被大单吃掉

新订单簿：
买1: 0.3500 @ $30（我们的订单）
买2: 0.3490 @ $200
买3: 0.3480 @ $500

执行结果：
- 前方保护变为 $0 < $500 ✗
- 触发"保护不足"
- 全局扫描，找到买3满足保护
- 撤单并重新挂在 0.3480（买3价位）
- 新的前方保护 = $230（买1 $30 + 买2 $200）
```

### 触发器 B：档位超标（范围内补位）

**触发条件**：当前订单的档位 > `check_bid_position`

**调整策略**：
- **限制搜索范围**：只在买1到买`check_bid_position`之间寻找
- **目的**：补位到更靠前的位置，提升竞争力
- **执行**：撤销当前订单，在新位置重新下单

**示例**：
```
配置：check_bid_position = 5

当前状态：
- 挂单：0.3460 @ $30（买6价位）

订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400
买3: 0.3500 @ $300
买4: 0.3490 @ $200
买5: 0.3480 @ $100
买6: 0.3460 @ $30（我们的订单）

执行结果：
- 当前档位 6 > 5 ✗
- 触发"档位超标"
- 扫描买1-5，买1满足保护
- 撤单并重新挂在 0.3510（买2价位）
- 新的前方保护 = $800
```

### 两个触发器的区别

| 特性 | 保护不足 | 档位超标 |
|------|---------|---------|
| **触发条件** | 前方保护 < min_protection | 档位 > check_bid_position |
| **搜索范围** | 全局（无限制） | 买1 到 check_bid_position |
| **优先级** | 安全第一 | 竞争力优先 |
| **可能结果** | 可能挂得很深 | 保证在限制范围内 |

---

## 四、保护金额计算详解

### 什么是保护金额？

保护金额是指您的挂单**前方**所有买单的总金额。这些订单为您的订单提供"保护"，因为买家必须先吃掉这些订单才能成交到您的订单。

### 计算方法

脚本通过 `_get_rank_and_protection` 方法计算：

1. **确定档位**：统计有多少个价格高于我们的订单
2. **累计金额**：
   - 所有价格高于我们订单的档位金额
   - 同价格档位中，排在我们前面的订单金额（估算为该档位总额 - 我们的订单金额）

### 示例

```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400
买3: 0.3500 @ $200

我们的挂单：0.3510 @ $30

计算结果：
- 档位：买2（因为 0.3510 是买2价格）
- 前方保护：$800（整个买1档位）
- 同档位其他订单：$400 - $30 = $370（估算）
```

### 为什么要减去自己的订单金额？

在同一价格档位中，我们假设自己的订单排在最后。这样计算出的保护金额更保守、更安全。

---

## 五、完整流程示例

### 场景：从初始化到调整

**配置**：
- `check_bid_position = 5`
- `min_protection_amount = $500`
- `order_amount = $30`

#### 步骤 1：首次下单

```
订单簿：
买1: 0.3520 @ $800
买2: 0.3510 @ $400
买3: 0.3500 @ $300

执行：
1. 搜索买1-5范围
2. 买1金额 $800 >= $500 ✓
3. 挂单价格 = 0.3520 - 0.001 = 0.3510
4. 下单成功：0.3510 @ $30
5. 档位：买2，前方保护：$800
```

#### 步骤 2：市场变化，触发保护不足

```
新订单簿（买1被吃掉）：
买1: 0.3510 @ $430（包含我们的 $30）
买2: 0.3500 @ $300
买3: 0.3490 @ $500

检测：
- 我们的订单现在是买1
- 前方保护 = $0 < $500 ✗
- 触发"保护不足"

调整：
1. 全局扫描
2. 买1 $430 < $500 ✗
3. 买1+买2 $730 >= $500 ✓
4. 撤单并重新挂在 0.3500（买2价格）
5. 新档位：买2，前方保护：$400（买1中除我们外的订单）
```

#### 步骤 3：市场恢复，触发档位超标

```
新订单簿（大量买单进入）：
买1: 0.3530 @ $900
买2: 0.3520 @ $800
买3: 0.3510 @ $600
买4: 0.3505 @ $400
买5: 0.3502 @ $300
买6: 0.3500 @ $330（包含我们的 $30）

检测：
- 我们的订单现在是买6
- 档位 6 > 5 ✗
- 触发"档位超标"

调整：
1. 扫描买1-5范围
2. 买1金额 $900 >= $500 ✓
3. 撤单并重新挂在 0.3520 - 0.001 = 0.3510（买3价格）
4. 新档位：买3，前方保护：$1700（买1 + 买2）
```

---

## 六、设计原则

### 1. 安全优先

脚本的核心目标是**提供流动性而非成交**。所有逻辑都围绕这一原则：

- **买1特殊处理**：永不直接挂买1价，避免被快速成交
- **保护金额机制**：确保前方有足够的订单作为缓冲
- **双重触发器**：保护不足时全局扫描，确保订单始终安全

### 2. 灵活应对市场变化

- **首次下单**：严格限制在 `check_bid_position` 范围内，避免挂得太深
- **保护不足**：全局扫描，不受档位限制，保命优先
- **档位超标**：范围内补位，平衡安全与竞争力

### 3. 透明可控

- **详细日志**：记录每次下单、调整的原因和结果
- **清晰触发条件**：明确什么情况下会调整订单
- **可配置参数**：用户可以根据需求调整保护金额和档位限制

### 4. 成交检测

脚本会定期检查订单状态，如果检测到订单被成交（status = 3 或 'filled'），会：
- 记录警告日志：`⚠️ [非预期成交]`
- 显示成交详情：市场、价格、金额、持续时间
- 从监控列表中移除该订单

---

## 七、关键特性总结

✅ **永不直接挂买1价**
- 即使买1满足保护，也会挂在 `买1价 - 0.001`
- 降低被快速成交的风险

✅ **累计计算保护金额**
- 从买1开始累加，直到满足 `min_protection_amount`
- `check_bid_position = 5` 意味着会累计计算买1-5的保护

✅ **智能调整策略**
- 保护不足 → 全局扫描（安全第一）
- 档位超标 → 范围内补位（竞争力优先）

✅ **最优情况**
- 挂在买2档位（买1价 - 0.001）
- 前方有整个买1档位保护
- 既安全又有竞争力

---

**本文档完整描述了 Solo Market 脚本的执行逻辑和设计原理。如有疑问，请参考代码注释或联系开发者。**
